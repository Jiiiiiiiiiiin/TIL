# Pandas

대부분의 데이터는 **시계열(series)**이나 **표(table)**의 형태로 나타낼 수 있다. 판다스(Pandas) 패키지는 이러한 데이터를 다루기 위한 **시리즈(`Series`) 클래스**와 **데이터프레임(`DataFrame`) 클래스**를 제공한다.



## 1. Pandas Package

#### 1) import pandas as np

```python
import pandas as np
```



#### 2) Series Class : Series = Value + Index 

Series class. 시리즈 `Series` 클래스는 넘파이에서 제공하는 1차원 배열과 비슷하지만 각 **데이터의 의미를 표시하는 인덱스(index)**를 붙일 수 있다. **데이터 자체는 값(value)**라고 한다.

> **시리즈 = 값(value) + 인덱스(index)**



#### 3) Series creation: Lable & 

S데이터를 리스트나 1차원 배열 형식으로 `Series` 클래스 생성자에 넣어주면 시리즈 클래스 객체를 만들 수 있다. 이 때 인덱스의 길이는 데이터의 길이와 같아야 한다. 다음 예에서 이 “서울”, “부산” 등의 문자열이 인덱스의 값이다. **인덱스의 값을 인덱스 라벨(label)**이라고도 한다. 인덱스 라벨은 문자열 뿐 아니라 날짜, 시간, 정수 등도 가능하다.

```python
s = pd.Series([9904312, 3448737, 2890451, 2466052],
              index=["서울", "부산", "인천", "대구"])
s
```

```
서울    9904312
부산    3448737
인천    2890451
대구    2466052
dtype: int64
```



만약 인덱스를 지정하지 않고 시리즈를 만들면 시리즈의 인덱스는 0부터 시작하는 정수값이 된다.	

```python
pd.Series(range(10, 14))
```

```
0    10
1    11
2    12
3    13
dtype: int64
```



시리즈의 인덱스는 `index` 속성으로 접근할 수 있다. 시리즈의 값은 1차원 배열이며 `values` 속성으로 접근할 수 있다. "**`Series.index` 속성 `Series.values` 속성**"

```python
s.index	
```

```
Index(['서울', '부산', '인천', '대구'], dtype='object')
```



```python
s.values	# 넘파이에서는 배열
```



```
array([9904312, 3448737, 2890451, 2466052])
```



#### 4) Series operation

넘파이 배열처럼 시리즈도 벡터화 연산을 할 수 있지만 **연산은 시리즈의 값에만 적용되며 인덱스 값은 변하지 않는다**.

```python
s / 1000000
```

```
도시
서울    9.904312
부산    3.448737
인천    2.890451
대구    2.466052
Name: 인구, dtype: float64
```



#### 5) Series Indexing

시리즈 데이터를 인덱싱하면 **값**이 나온다.

```python
s[1], s["부산"]
```

```
(3448737, 3448737)
```



##### (a) 넘파이 배열 인덱싱 - fancy indexing

##### (b) 인덱스 라벨을 이용한 인덱싱

배열 인덱싱을 하면 부분적인 값을 가지는 시리즈 자료형을 반환한다. 자료의 순서를 바꾸거나 특정한 자료만 선택할 수 있다.

참고로 fancy indexing은 한번에 여러 배열 요소에 엑세스 하기 위해 인덱스 배열을 전달하는 것을 의미한다. a[b]의 경우 b배열의 값을 인덱스로 하여 a 의 값들을 추출한다.

```python
s[[0, 3, 1]]
```

```
도시
서울    9904312
대구    2466052
부산    3448737
Name: 인구, dtype: int64
```



```python
s[["서울", "대구", "부산"]]
```

```
도시
서울    9904312
대구    2466052
부산    3448737
Name: 인구, dtype: int64
```



```python
s[(250e4 < s) & (s < 500e4)]  # 인구가 250만 초과, 500만 미만인 경우
```

```
도시
부산    3448737
인천    2890451
Name: 인구, dtype: int64
```



```python
s[(250e4 < s) & (s < 500e4)]  # 인구가 250만 초과, 500만 미만인 경우
```

```
도시
부산    3448737
인천    2890451
Name: 인구, dtype: int64
```



##### (c) 인덱스 라벨을 이용한 슬라이싱(slicing)

```python
s[1:3]  # 두번째(1)부터 세번째(2)까지 (네번째(3) 미포함)
```

```
도시
부산    3448737
인천    2890451
Name: 인구, dtype: int64
```



문자열 라벨을 이용한 슬라이싱은 숫자 인덱싱과 달리 콜론(:) 기호 뒤에 오는 값도 결과에 포함된다

```python
s["부산":"대구"]  # 부산에서 대구까지 (대구도 포함)
```

```
도시
부산    3448737
인천    2890451
대구    2466052
Name: 인구, dtype: int64
```



라벨 값이 영문인 경우에는 인덱스 라벨이 속성인것처럼 점(.)을 이용하여 해당 인덱스 값에 접근할 수도 있다.

```python
s0 = pd.Series(range(3), index=["a", "b", "c"])
s0
```

```
a    0
b    1
c    2
dtype: int64
```



```python
s0.a
```

```
0
```



#### 6) Series and Dictionary

**시리즈 객체는** 라벨 값에 의해 인덱싱이 가능하므로 실질적으로 **인덱스 라벨 값을 키(key)로 가지는 딕셔너리 자료형**과 같다고 볼 수 있다. 따라서 딕셔너리 자료형에서 제공하는 **`in` 연산도 가능하고 `items` 메서드를 사용하면 `for` 루프를 통해 각 원소의 키(key)와 값(value)을 접근**할 수도 있다.



##### (a) in 연산

```python
"서울" in s  # 인덱스 라벨 중에 서울이 있는가
```

```
True
```



```python
"대전" in s  # 인덱스 라벨 중에 대전이 있는가
```

```
False
```



##### (b) for 루프

```python
for k, v in s.items():
    print("%s = %d" % (k, v))  #%s is string, %d is integer dicimal, %float, % is placeholder
```

```
서울 = 9904312
부산 = 3448737
인천 = 2890451
대구 = 2466052
```



##### (c) dictionary

딕셔너리 객체에서 시리즈를 만들 수도 있다. 이번에는 2010년의 인구 자료를 `s2`라는 이름의 시리즈로 만들어 보자. 이 데이터에는 대구의 인구 자료는 없지만 대신 대전의 인구 자료가 포함되어 있다.

```python
s2 = pd.Series({"서울": 9631482, "부산": 3393191, "인천": 2632035, "대전": 1490158})
s2
```

```
서울    9631482
부산    3393191
인천    2632035
대전    1490158
dtype: int64
```



##### (d) dictionary ordering - list

딕셔너리의 시리즈는 데이터 순서가 보장되지 않는다. 순서를 정하고 싶다면 인덱스를 리스트로 지정해야 한다.

```python
s2 = pd.Series({"서울": 9631482, "부산": 3393191, "인천": 2632035, "대전": 1490158},
               index=["부산", "서울", "인천", "대전"])
s2
```

```
부산    3393191
서울    9631482
인천    2632035
대전    1490158
dtype: int64
```



#### 7) Index operation

##### (a) 같은 인덱스의 연산

**두 시리즈에 대해 연산을 하는 경우 인덱스가 같은 데이터에 대해서만 차이**를 구한다.

```python
ds = s - s2
ds
```

```
대구         NaN
대전         NaN
부산     55546.0
서울    272830.0
인천    258416.0
dtype: float64
```



##### (b) 같은 자리의 value의 연산

각 value를 가지고 연산을 하는 경우, 인덱스 라벨끼리 메칭되지 않고 같은 인덱스 자리의 value들이 연산된다.

```python
s.values - s2.values
```

```
array([ 6511121, -6182745,   258416,   975894])
```



##### (c) NaN  찾기 ds.notnull()

대구와 대전의 경우에는 2010년 자료와 2015년 자료가 모두 존재하지 않기 때문에 계산이 불가능하므로 `NaN`(Not a Number)이라는 값을 가지게 된다. 또한 `NaN` 값이 `float` 자료형에서만 가능하므로 다른 계산 결과도 모두 `float` 자료형이 되었다는 점에 주의한다. `NaN`이 아닌 값을 구하려면 `notnull` 메서드를 사용한다.

```python
ds.notnull()
```

```
대구    False
대전    False
부산     True
서울     True
인천     True
dtype: bool
```



##### (d) NaN 아닌 value 찾기 ds[ds.notnull()]

```python
ds[ds.notnull()]
```

```
부산     55546.0
서울    272830.0
인천    258416.0
dtype: float64
```



인구 증가율(%) 연산

```python
rs = (s - s2) / s2 * 100
rs = rs[rs.notnull()]
rs
```

```
부산    1.636984
서울    2.832690
인천    9.818107
dtype: float64
```



#### 8) Data - update, add and delete

인덱싱을 이용하면 딕셔너리처럼 데이터를 갱신(update)하거나 추가(add)할 수 있다.



##### (a) 갱신 ds["라벨"] = 갱신값

```python
rs["부산"] = 1.63
rs
```

```
부산    1.630000
서울    2.832690
인천    9.818107
dtype: float64
```

##### (b) 추가 ds["추가라벨"] = 값 

```python
rs["대구"] = 1.41
rs
```

```
부산    1.630000
서울    2.832690
인천    9.818107
대구    1.410000
dtype: float64
```



##### (c) 삭제 del ds["라벨"]

데이터를 삭제할 때도 딕셔너리처럼 `del` 명령을 사용한다.

```python
del rs["서울"]
rs
```

```
부산    1.630000
인천    9.818107
대구    1.410000
dtype: float64
```



#### 9) DataFrame Class

시리즈가 1차원 벡터 데이터에 행방향 인덱스(row index)를 붙인 것이라면 **데이터프레임 `DataFrame` 클래스는 2차원 행렬 데이터에 인덱스를 붙인 것**과 비슷하다. **공통 인덱스를 가지는 열 시리즈(column series)를 딕셔너리로 묶어놓은 것**이라고 보는 것이 더 정확하다. 2차원이므로 각각의 **행 데이터의 이름이 되는 행 인덱스(row index)** 뿐 아니라 각각의 **열 데이터의 이름이 되는 열 인덱스(column index)**도 붙일 수 있다.



##### (a) DataFrame creation

**열 리스트/배열 준비 - 열 이름을 키로 만드는 딕셔너리 - 클래스 생성자 + columns인수 + index인수(행)**

데이터프레임을 만드는 가장 간단한 방법은 다음과 같다.

1. 하나의 <u>열이 되는 데이터를 리스트나 일차원 배열</u>을 준비한다.
2. 이 각각의 <u>열에 대한 이름(라벨)을 키로 가지는 딕셔너리를 만든다</u>.
3. 이 <u>데이터를 `DataFrame` 클래스 생성자에 넣는다. 동시에 열방향 인덱스는 `columns` 인수로, 행방향 인덱스는 `index` 인수로 지정</u>한다.

```python
data = {
    "2015": [9904312, 3448737, 2890451, 2466052],
    "2010": [9631482, 3393191, 2632035, 2431774],
    "2005": [9762546, 3512547, 2517680, 2456016],
    "2000": [9853972, 3655437, 2466338, 2473990],
    "지역": ["수도권", "경상권", "수도권", "경상권"],
    "2010-2015 증가율": [0.0283, 0.0163, 0.0982, 0.0141]
}
columns = ["지역", "2015", "2010", "2005", "2000", "2010-2015 증가율"]
index = ["서울", "부산", "인천", "대구"]
df = pd.DataFrame(data, index=index, columns=columns)
df
```

|      |   지역 |    2015 |    2010 |    2005 |    2000 | 2010-2015 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: |
| 서울 | 수도권 | 9904312 | 9631482 | 9762546 | 9853972 |           0.0283 |
| 부산 | 경상권 | 3448737 | 3393191 | 3512547 | 3655437 |           0.0163 |
| 인천 | 수도권 | 2890451 | 2632035 | 2517680 | 2466338 |           0.0982 |
| 대구 | 경상권 | 2466052 | 2431774 | 2456016 | 2473990 |           0.0141 |



###### (a-1) Data access

df.values, df.colums, df.index

시리즈와 마찬가지로 데이터만 접근하려면 `values` 속성을 사용한다. 열방향 인덱스와 행방향 인덱스는 각각 `columns`, `index` 속성으로 접근한다.

```python
df.values
```

```
array([['수도권', 9904312, 9631482, 9762546, 9853972, 0.0283],
       ['경상권', 3448737, 3393191, 3512547, 3655437, 0.0163],
       ['수도권', 2890451, 2632035, 2517680, 2466338, 0.0982],
       ['경상권', 2466052, 2431774, 2456016, 2473990, 0.0141]], dtype=object)
```



```python
df.columns
```

```
Index(['지역', '2015', '2010', '2005', '2000', '2010-2015 증가율'], dtype='object')
```



```python
df.index
```

```
Index(['서울', '부산', '인천', '대구'], dtype='object')
```



###### (a-2) Index naming

df.index.name, df.columns.name

시리즈에서 처럼 열방향 인덱스와 행방향 인덱스에 이름을 붙이는 것도 가능하다.

```python
df.index.name = "도시"
df.columns.name = "특성"
df
```

|     특성 |   지역 |    2015 |    2010 |    2005 |    2000 | 2010-2015 증가율 |
| -------: | -----: | ------: | ------: | ------: | ------: | ---------------: |
| **도시** |        |         |         |         |         |                  |
|     서울 | 수도권 | 9904312 | 9631482 | 9762546 | 9853972 |           0.0283 |
|     부산 | 경상권 | 3448737 | 3393191 | 3512547 | 3655437 |           0.0163 |
|     인천 | 수도권 | 2890451 | 2632035 | 2517680 | 2466338 |           0.0982 |
|     대구 | 경상권 | 2466052 | 2431774 | 2456016 | 2473990 |           0.0141 |



###### (a-3) Transpose

데이터프레임은 전치(transpose)를 포함하여 넘파이 2차원 배열이 가지는 대부분의 속성이나 메서드를 지원한다.

```python
df.T
```

|             도시 |    서울 |    부산 |    인천 |    대구 |
| ---------------: | ------: | ------: | ------: | ------: |
|             특성 |         |         |         |         |
|             지역 |  수도권 |  경상권 |  수도권 |  경상권 |
|             2015 | 9904312 | 3448737 | 2890451 | 2466052 |
|             2010 | 9631482 | 3393191 | 2632035 | 2431774 |
|             2005 | 9762546 | 3512547 | 2517680 | 2456016 |
|             2000 | 9853972 | 3655437 | 2466338 | 2473990 |
| 2010-2015 증가율 |  0.0283 |  0.0163 |  0.0982 |  0.0141 |





##### (b) Column data - update, add and delete

데이터프레임은 열 시리즈의 딕셔너리으로 볼 수 있으므로 열 단위로 데이터를 갱신하거나 추가, 삭제할 수 있다.

###### (b-1) update / add

df["column index"] = update or add 내용

```python
# "2010-2015 증가율"이라는 이름의 열 추가
df["2010-2015 증가율"] = df["2010-2015 증가율"] * 100
df
```

| 특성 |   지역 |    2015 |    2010 |    2005 |    2000 | 2010-2015 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: |
| 도시 |        |         |         |         |         |                  |
| 서울 | 수도권 | 9904312 | 9631482 | 9762546 | 9853972 |             2.83 |
| 부산 | 경상권 | 3448737 | 3393191 | 3512547 | 3655437 |             1.63 |
| 인천 | 수도권 | 2890451 | 2632035 | 2517680 | 2466338 |             9.82 |
| 대구 | 경상권 | 2466052 | 2431774 | 2456016 | 2473990 |             1.41 |



```python
# "2005-2010 증가율"이라는 이름의 열 추가
df["2005-2010 증가율"] = ((df["2010"] - df["2005"]) / df["2005"] * 100).round(2)
df
```

| 특성 |   지역 |    2015 |    2010 |    2005 |    2000 | 2010-2015 증가율 | 2005-2010 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: | ---------------: |
| 도시 |        |         |         |         |         |                  |                  |
| 서울 | 수도권 | 9904312 | 9631482 | 9762546 | 9853972 |             2.83 |            -1.34 |
| 부산 | 경상권 | 3448737 | 3393191 | 3512547 | 3655437 |             1.63 |            -3.40 |
| 인천 | 수도권 | 2890451 | 2632035 | 2517680 | 2466338 |             9.82 |             4.54 |
| 대구 | 경상권 | 2466052 | 2431774 | 2456016 | 2473990 |             1.41 |            -0.99 |



###### (c-3) deletion

del df["column index"]

```python
# "2010-2015 증가율"이라는 이름의 열 삭제
del df["2010-2015 증가율"]
df
```

| 특성 |   지역 |    2015 |    2010 |    2005 |    2000 | 2005-2010 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: |
| 도시 |        |         |         |         |         |                  |
| 서울 | 수도권 | 9904312 | 9631482 | 9762546 | 9853972 |            -1.34 |
| 부산 | 경상권 | 3448737 | 3393191 | 3512547 | 3655437 |            -3.40 |
| 인천 | 수도권 | 2890451 | 2632035 | 2517680 | 2466338 |             4.54 |
| 대구 | 경상권 | 2466052 | 2431774 | 2456016 | 2473990 |            -0.99 |



##### (c) Column indexing

**데이터프레임은 열 라벨을 키로, 열 시리즈를 값으로 가지는 딕셔너리**와 비슷하다고 하였다. 따라서 데이터프레임을 **인덱싱을 할 때도 열 라벨(column label)을 키값으로 생각하여 인덱싱**을 할 수 있다. **인덱스로 라벨 값을 하나만 넣으면 시리즈 객체가 반환**되고 **라벨의 배열 또는 리스트를 넣으면 부분적인 데이터프레임이 반환**된다.

###### (c-1) df["열 라벨"]  df.열라벨

인덱싱 시리즈 반환

```python
# 하나의 열만 인덱싱하면 시리즈가 반환된다.
df["지역"]
```

```
도시
서울    수도권
부산    경상권
인천    수도권
대구    경상권
Name: 지역, dtype: object
```



```python
type(df["지역"])
```

```
pandas.core.series.Series
```



###### (c-2) df[["열라벨1", "열라벨2"]]

부분적 데이터프레임 반환

```python
# 여러개의 열을 인덱싱하면 부분적인 데이터프레임이 반환된다.
df[["2010", "2015"]]
```

| 특성 |    2010 |    2015 |
| ---: | ------: | ------: |
| 도시 |         |         |
| 서울 | 9631482 | 9904312 |
| 부산 | 3393191 | 3448737 |
| 인천 | 2632035 | 2890451 |
| 대구 | 2431774 | 2466052 |

###### (c-5) df.head(), df.tail()), df.head().df.tail()



###### (c-3) df[["열라벨"]]

리스트로 빼낸 데이터프레임

하나의 열만 빼내면서 데이터프레임 자료형을 유지하고 싶다면 원소가 하나인 리스트를 써서 인덱싱하면 된다.

```python
# 2010이라는 열을 반환하면서 데이터프레임 자료형을 유지
df[["2010"]]
```

| 특성 |    2010 |
| ---: | ------: |
| 도시 |         |
| 서울 | 9631482 |
| 부산 | 3393191 |
| 인천 | 2632035 |
| 대구 | 2431774 |

```python
type(df[["2010"]])
```

```
pandas.core.frame.DataFrame
```



###### (c-4) 열 라벨이 있으면 정수인덱싱X

데이터프레임의 열 인덱스가 문자열 라벨을 가지고 있는 경우에는 순서를 나타내는 정수 인덱스를 열 인덱싱에 사용할 수 없다. **정수 인덱싱의 슬라이스는 뒤에서 설명하겠지만 행(row)을 인덱싱할 때 사용**하므로 열을 인덱싱할 때는 쓸 수 없다. 정수 인덱스를 넣으면 `KeyError` 오류가 발생하는 것을 볼 수 있다.

```python
df[0]

...(생략)...
Key Error 0
```



(c-5) 열 라벨이 정수면 정수인덱싱O

원래부터 문자열이 아닌 정수형 열 인덱스를 가지는 경우에는 인덱스 값으로 정수를 사용할 수 있다.

```python
df2 = pd.DataFrame(np.arange(12).reshape(3, 4))
df2
```

|      |    0 |    1 |    2 |    3 |
| ---: | ---: | ---: | ---: | ---: |
|    0 |    0 |    1 |    2 |    3 |
|    1 |    4 |    5 |    6 |    7 |
|    2 |    8 |    9 |   10 |   11 |

```python
df2[2]
```

```
0     2
1     6
2    10
Name: 2, dtype: int64
```



```python
df2[[1, 2]]
```

|      |    1 |    2 |
| ---: | ---: | ---: |
|    0 |    1 |    2 |
|    1 |    5 |    6 |
|    2 |    9 |   10 |



##### (d) Row indexing - slicing

행 단위로 인덱싱을 하고자 하면 항상 슬라이싱(slicing)을 해야 한다. 인덱스의 값이 문자 라벨이면 라벨 슬라이싱도 가능하다.

```python
df[:1]
```

| 특성 |   지역 |    2015 |    2010 |    2005 |    2000 | 2005-2010 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: |
| 도시 |        |         |         |         |         |                  |
| 서울 | 수도권 | 9904312 | 9631482 | 9762546 | 9853972 |            -1.34 |

```python
df[1:2]
```

| 특성 |   지역 |    2015 |    2010 |    2005 |    2000 | 2005-2010 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: |
| 도시 |        |         |         |         |         |                  |
| 부산 | 경상권 | 3448737 | 3393191 | 3512547 | 3655437 |             -3.4 |

```python
df[1:3]
```

| 특성 |   지역 |    2015 |    2010 |    2005 |    2000 | 2005-2010 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: |
| 도시 |        |         |         |         |         |                  |
| 부산 | 경상권 | 3448737 | 3393191 | 3512547 | 3655437 |            -3.40 |
| 인천 | 수도권 | 2890451 | 2632035 | 2517680 | 2466338 |             4.54 |

```python
df["서울":"부산"]
```

| 특성 |   지역 |    2015 |    2010 |    2005 |    2000 | 2005-2010 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: |
| 도시 |        |         |         |         |         |                  |
| 서울 | 수도권 | 9904312 | 9631482 | 9762546 | 9853972 |            -1.34 |
| 부산 | 경상권 | 3448737 | 3393191 | 3512547 | 3655437 |            -3.40 |



##### (e) Data indexing

df ["열라벨"] ["행라벨"]  

데이터프레임에서 열 라벨로 시리즈를 인덱싱하면 시리즈가 된다. 이 시리즈를 다시 행 라벨로 인덱싱하면 개별 데이터가 나온다.

```python
df["2015"]["서울"]
```

```
9904312
```



## 2. DataFrame: Getting data in/out

#### 1) Command `%%writefile`

샘플 데이터로 사용할 CSV 파일을 `%%writefile` 매직(magic) 명령으로 만든다. 셀에 서술한 내용대로 텍스트 파일을 만드는 명령이다.

```python
%%writefile sample1.csv
c1, c2, c3
1, 1.11, one
2, 2.22, two
3, 3.33, three
```

```python
Writing sample1.csv
```



#### 2) Reading CSV file

CSV(Comman Separated Value)  파일 포맷은 데이터 값이 쉽표(comma)로 구분되는 텍스트 파일.

##### (a) read pandas.read_csv

CSV 파일로부터 데이터를 읽어 데이터프레임을 만들 때는 `pandas.read_csv` 함수를 사용한다. 함수의 입력값으로 파일 이름을 넣는다.

```python
pd.read_csv('sample1.csv')
```

|      |   c1 |   c2 |    c3 |
| ---: | ---: | ---: | ----: |
|    0 |    1 | 1.11 |   one |
|    1 |    2 | 2.22 |   two |
|    2 |    3 | 3.33 | three |

위에서 읽은 데이터에는 열 인덱스는 있지만 행 인덱스 정보가 없으므로 **0부터 시작하는 정수 인덱스가 자동으로 추가**되었다.



##### (b) 열 인덱스 names

데이터 파일에 열 인덱스 정보가 없는 경우에는 `read_csv` 명령의 `names` 인수로 설정할 수 있다.

```python
%%writefile sample2.csv
1, 1.11, one
2, 2.22, two
3, 3.33, three
```

```python
Writing sample2.csv
```

```python
pd.read_csv('sample2.csv', names=['c1', 'c2', 'c3'])
```

|      |   c1 |   c2 |    c3 |
| ---: | ---: | ---: | ----: |
|    0 |    1 | 1.11 |   one |
|    1 |    2 | 2.22 |   two |
|    2 |    3 | 3.33 | three |



##### (c) 특정 열을 행 인덱스로 index_col

테이블 내의 **특정한 열을 행 인덱스로 지정**하고 싶으면 `index_col` 인수를 사용한다.

```python
pd.read_csv('sample1.csv', index_col='c1')
```

|      |   c2 |    c3 |
| ---: | ---: | ----: |
|   c1 |      |       |
|    1 | 1.11 |   one |
|    2 | 2.22 |   two |
|    3 | 3.33 | three |



##### (d) 구분 sep='\s+'

확장자가 CSV가 아닌 파일 즉, 데이터를 구분하는 구분자(separator)가 쉼표(comma)가 아니면 `sep` 인수를 써서 구분자를 사용자가 지정해준다. 만약 길이가 정해지지 않은 공백이 구분자인 경우에는 `\s+` 정규식(regular expression) 문자열을 사용한다.

```python
%%writefile sample3.txt
c1        c2        c3        c4
0.179181 -1.538472  1.347553  0.43381
1.024209  0.087307 -1.281997  0.49265
0.417899 -2.002308  0.255245 -1.10515
```

```python
Writing sample3.txt
```

```python
pd.read_table('sample3.txt', sep='\s+')
```

|      |       c1 |        c2 |        c3 |       c4 |
| ---: | -------: | --------: | --------: | -------: |
|    0 | 0.179181 | -1.538472 |  1.347553 |  0.43381 |
|    1 | 1.024209 |  0.087307 | -1.281997 |  0.49265 |
|    2 | 0.417899 | -2.002308 |  0.255245 | -1.10515 |



##### (e) 건너뛰기 skiprows=[,]

만약 자료 파일 중에 건너 뛰어야 할 행이 있으면 `skiprows` 인수를 사용한다.

```python
%%writefile sample4.txt
파일 제목: sample4.txt
데이터 포맷의 설명:
c1, c2, c3
1, 1.11, one
2, 2.22, two
3, 3.33, three
```

```python
Writing sample4.txt
```

```python
pd.read_csv('sample4.txt', skiprows=[0, 1])
```

|      |   c1 |   c2 |    c3 |
| ---: | ---: | ---: | ----: |
|    0 |    1 | 1.11 |   one |
|    1 |    2 | 2.22 |   two |
|    2 |    3 | 3.33 | three |



##### (f) na_values=[NaN이 대신할 값]

특정한 값을 NaN으로 취급하고 싶으면 `na_values` 인수에 NaN 값으로 취급할 값을 넣는다.

```python
%%writefile sample5.csv
c1, c2, c3
1, 1.11, one
2, , two
누락, 3.33, three
```

```python
Writing sample5.csv
```

```py
df = pd.read_csv('sample5.csv', na_values=['누락', ' '])
df
```

|      |   c1 |   c2 |    c3 |
| ---: | ---: | ---: | ----: |
|    0 |  1.0 | 1.11 |   one |
|    1 |  2.0 |  NaN |   two |
|    2 |  NaN | 3.33 | three |



#### 3) Writing CSV file

##### (a) df.to_csv(파일)

파이썬의 데이터프레임 값을 CSV 파일로 출력하고 싶으면 `to_csv` 메서드를 사용한다.

```python
df.to_csv('sample6.csv')
```



##### (b) 파일내용확인 !cat 파일

 `cat` 셸 명령으로 파일의 내용을 확인할 수 있다. !는 셸 함수를 사용하기 위한 아이파이썬(IPython) 매직 명령.

```python
!cat sample6.csv  # 윈도우에서는 !type sample6.csv 함수를 사용
```

```python
,c1, c2, c3
0,1.0, 1.11, one
1,2.0, , two
2,, 3.33, three
```



##### (c) sep= 구분자

 `sep` 인수로 구분자를 바꿀 수 있다.

```python
df.to_csv('sample7.txt', sep='|')
```

```python
!cat sample7.txt
```

```python
|c1| c2| c3
0|1.0| 1.11| one
1|2.0| | two
2|| 3.33| three
```



##### (d) na_rep = NaN이 대체할 값 

또 `na_rep` 인수로 NaN 표시값을 바꿀 수도 있다.

```python
df.to_csv('sample8.csv', na_rep='누락')
```

```python
!cat sample8.csv
```

```python
,c1, c2, c3
0,1.0, 1.11, one
1,2.0, , two
2,누락, 3.33, three
```



##### (e) df.index, df.header 지정

`index`, `header` 인수를 지정하여 인덱스 및 헤더 출력 여부를 지정하는 것도 가능.

```python
df.index = ["a", "b", "c"]
df
```

|      |   c1 |   c2 |    c3 |
| ---: | ---: | ---: | ----: |
|    a |  1.0 | 1.11 |   one |
|    b |  2.0 |      |   two |
|    c |  NaN | 3.33 | three |

```python
df.to_csv('sample9.csv', index=False, header=False)
```

```python
!cat sample9.csv  # 윈도우에서는 !type sample6.csv 함수를 사용
```

```python
1.0, 1.11, one
2.0, , two
, 3.33, three
```



#### 4) Loading CSV file from web page

 `read_csv` 명령 사용시 파일 패스 대신 URL을 지정하면 Pandas가 직접 해당 파일을 다운로드하여 읽어들인다. 다음은 저자의 github 웹사이트에 저장되어 있는 데이터 파일을 원격으로 읽는 명령이다.

```
df = pd.read_csv(url)
```



## 3. DataFrame: Advanced indexing

Pandas는 numpy행렬과 같이 쉼표를 사용한 `(행 인덱스, 열 인덱스)` 형식의 2차원 인덱싱을 지원하기 위해 다음과 같은 특별한 인덱서(indexer) 속성도 제공.

- `loc` : 라벨값 기반의 2차원 인덱싱
- `iloc` : 순서를 나타내는 정수 기반의 2차원 인덱싱



#### 1) loc indexer 

df.loc[행 인덱싱값], df.loc[행 인덱싱값, 열 인덱싱값]

```python
df.loc[행 인덱싱값]
```

또는

```python
df.loc[행 인덱싱값, 열 인덱싱값]
```



인덱싱 값은 다음 중 하나이다. **행 인덱싱값은 정수 또는 행 인덱스데이터이고 열 인덱싱값은 라벨 문자열**이다.

- 인덱스데이터
- 인덱스데이터 슬라이스
- 인덱스데이터 리스트
- 같은 행 인덱스를 가지는 불리언 시리즈 (행 인덱싱의 경우)
- 또는 위의 값들을 반환하는 함수



```python
df = pd.DataFrame(np.arange(10, 22).reshape(3, 4),
                  index=["a", "b", "c"],
                  columns=["A", "B", "C", "D"])
df
```

|      |    A |    B |    C |    D |
| ---: | ---: | ---: | ---: | ---: |
|    a |   10 |   11 |   12 |   13 |
|    b |   14 |   15 |   16 |   17 |
|    c |   18 |   19 |   20 |   21 |



##### (a) indexing: one single label

 **`loc` 인덱서를 사용하면서 인덱스를 하나만 넣으면 행(row)**을 선택한다.

인덱스데이터가 “a”인 행을 고르면 해당하는 **행이 시리즈로 출력**된다. 

```python
df.loc["a"]
```

```
A    10
B    11
C    12
D    13
Name: a, dtype: int64
```



인덱스데이터의 슬라이스.

```python
df.loc["b":"c"]
```

|      |    A |    B |    C |    D |
| ---: | ---: | ---: | ---: | ---: |
|    b |   14 |   15 |   16 |   17 |
|    c |   18 |   19 |   20 |   21 |



 `loc`를 쓰지 않는 경우.

```python
df["b":"c"]
```

|      |    A |    B |    C |    D |
| ---: | ---: | ---: | ---: | ---: |
|    b |   14 |   15 |   16 |   17 |
|    c |   18 |   19 |   20 |   21 |



인덱스데이터의 리스트

```python
df.loc[["b", "c"]]
```

|      |    A |    B |    C |    D |
| ---: | ---: | ---: | ---: | ---: |
|    b |   14 |   15 |   16 |   17 |
|    c |   18 |   19 |   20 |   21 |



`loc`를 쓰지 않으면 KeyError 오류.

```python
# df[["b", "c"]]  # KeyError
```



불리언 시리즈 - 행을 선택하는 인덱싱값.

```python
df.A > 15
```

```python
a    False
b    False
c     True
Name: A, dtype: bool
```

```python
df.loc[df.A > 15]
```

|      |    A |    B |    C |    D |
| ---: | ---: | ---: | ---: | ---: |
|    c |   18 |   19 |   20 |   21 |



인덱스 대신 인덱스 값을 반환하는 함수. 

```python
def select_rows(df):
    return df.A > 15
```

```python
select_rows(df)
```

```
a    False
b    False
c     True
Name: A, dtype: bool
```

```python
df.loc[select_rows(df)]
```

|      |    A |    B |    C |    D |
| ---: | ---: | ---: | ---: | ---: |
|    c |   18 |   19 |   20 |   21 |



**`loc` 인덱서가 없는 경우에 사용했던 라벨 인덱싱이나 라벨 리스트 인덱싱은 불가능**하다.

```python
# df.loc["A"]  # KeyError
```

```python
# df.loc[["A", "B"]]  # KeyError
```



**행인덱스값이 정수인 경우, 슬라이싱도 라벨 슬라이싱 방식을 따르게 된다. 즉, 슬라이스의 마지막 값이 포함**된다.

```python
df2 = pd.DataFrame(np.arange(10, 26).reshape(4, 4), columns=["A", "B", "C", "D"])
df2
```

|      |    A |    B |    C |    D |
| ---: | ---: | ---: | ---: | ---: |
|    0 |   10 |   11 |   12 |   13 |
|    1 |   14 |   15 |   16 |   17 |
|    2 |   18 |   19 |   20 |   21 |
|    3 |   22 |   23 |   24 |   25 |

```python
df2.loc[1:2]
```

|      |    A |    B |    C |    D |
| ---: | ---: | ---: | ---: | ---: |
|    1 |   14 |   15 |   16 |   17 |
|    2 |   18 |   19 |   20 |   21 |



정리

| 인덱싱 값                     | 가능 | 결과 | 자료형       | 추가사항                                                  |
| ----------------------------- | ---- | ---- | ------------ | --------------------------------------------------------- |
| 행 인덱스값(정수)             | O    | 행   | 시리즈       |                                                           |
| 행 인덱스값(정수) 슬라이스    | O    | 행   | 데이터프레임 | `loc`가 없는 경우와 같음                                  |
| 행 인덱스값(정수) 리스트      | O    | 행   | 데이터프레임 |                                                           |
| 불리언 시리즈                 | O    | 행   | 데이터프레임 | 시리즈의 인덱스가 데이터프레임의 행 인덱스와 같아야 한다. |
| 불리언 시리즈를 반환하는 함수 | O    | 행   | 데이터프레임 |                                                           |
| 열 라벨                       | X    |      |              | `loc`가 없는 경우에만 쓸 수 있다.                         |
| 열 라벨 리스트                | X    |      |              | `loc`가 없는 경우에만 쓸 수 있다.                         |



##### (b) Indexing: rows and columns

인덱싱값을 행과 열 모두 받으려면 `df.loc[행 인덱스, 열 인덱스]`와 같은 형태로 사용한다. 행 인덱스 라벨값이 `a`, 열 인덱스 라벨값이 `A`인 위치의 값을 구하는 것은 다음과 같다.

```python
df.loc["a", "A"]
```

```
10
```



인덱싱값으로 라벨 데이터의 슬라이싱 또는 리스트를 사용할 수도 있다.

```python
df.loc["b":, "A"]
```

```
b    14
c    18
Name: A, dtype: int64
```



```python
df.loc["a", :]
```

```
A    10
B    11
C    12
D    13
Name: a, dtype: int64
```



```py
df.loc[["a", "b"], ["B", "D"]]
```

|      |    B |    D |
| ---: | ---: | ---: |
|    a |   11 |   13 |
|    b |   15 |   17 |



행 인덱스가 같은 불리언 시리즈나 이러한 불리언 시리즈를 반환하는 함수도 행의 인덱싱값이 될 수 있다.

```python
df.loc[df.A > 10, ["C", "D"]]
```

|      |    C |    D |
| ---: | ---: | ---: |
|    b |   16 |   17 |
|    c |   20 |   21 |



#### 2) iloc Indexer

`iloc` 인덱서는 `loc` 인덱서와 반대로 라벨이 아니라 **순서를 나타내는 정수(integer) 인덱스**만 받는다. 다른 사항은 `loc` 인덱서와 같다.

```python
df.iloc[0, 1]
```

```
11
```



```python
df.iloc[:2, 2]
```

```
a    12
b    16
Name: C, dtype: int64
```



```python
df.iloc[0, -2:]
```

```
C    12
D    13
Name: a, dtype: int64
```



```python
df.iloc[2:3, 1:3]
```

|      |    B |    C |
| ---: | ---: | ---: |
|    c |   19 |   20 |



`loc` 인덱서와 마찬가지로 인덱스가 **하나만 들어가면 행**을 선택한다.

```python
df.iloc[-1]
```

```
A    18
B    19
C    20
D    21
Name: c, dtype: int64
```



```python
df.iloc[-1] = df.iloc[-1] * 2
df
```

|      |    A |    B |    C |    D |
| ---: | ---: | ---: | ---: | ---: |
|    a |   10 |   11 |   12 |   13 |
|    b |   14 |   15 |   16 |   17 |
|    c |   36 |   38 |   40 |   42 |





## 4. DataFrame: Data manipulation

#### 1) Count elements 

##### (a) 시리즈 카운트 s.count()

 `count` 메서드를 사용한다. NaN 값은 세지 않는다. 

```python
s = pd.Series(range(10))
s[3] = np.nan
s
```

```python
0    0.0
1    1.0
2    2.0
3    NaN
4    4.0
5    5.0
6    6.0
7    7.0
8    8.0
9    9.0
dtype: float64
```

```python
s.count()
```

```
9
```



##### (b) df의 각 열 카운트 df.count()

열마다 별도로 데이터 갯수 카운트. df.count()

```python
np.random.seed(2)
df = pd.DataFrame(np.random.randint(5, size=(4, 4)), dtype=float)
df.iloc[2, 3] = np.nan
df
```

|      |    0 |    1 |    2 |    3 |
| ---: | ---: | ---: | ---: | ---: |
|    0 |  0.0 |  0.0 |  3.0 |  2.0 |
|    1 |  3.0 |  0.0 |  2.0 |  1.0 |
|    2 |  3.0 |  2.0 |  4.0 |  NaN |
|    3 |  4.0 |  3.0 |  4.0 |  2.0 |

```python
df.count()
```

```
0    4
1    4
2    4
3    3
dtype: int64
```



타이타닉호의 승객 데이터의 데이터프레임

```python
import seaborn as sns
titanic = sns.load_dataset("titanic")
titanic.head()
```

|      | survived | pclass |    sex |  age | sibsp | parch |    fare | embarked | class |   who | adult_male | deck | embark_town | alive | alone |
| ---: | -------: | -----: | -----: | ---: | ----: | ----: | ------: | -------: | ----: | ----: | ---------: | ---: | ----------: | ----: | ----: |
|    0 |        0 |      3 |   male | 22.0 |     1 |     0 |  7.2500 |        S | Third |   man |       True |  NaN | Southampton |    no | False |
|    1 |        1 |      1 | female | 38.0 |     1 |     0 | 71.2833 |        C | First | woman |      False |    C |   Cherbourg |   yes | False |
|    2 |        1 |      3 | female | 26.0 |     0 |     0 |  7.9250 |        S | Third | woman |      False |  NaN | Southampton |   yes |  True |
|    3 |        1 |      1 | female | 35.0 |     1 |     0 | 53.1000 |        S | First | woman |      False |    C | Southampton |   yes | False |
|    4 |        0 |      3 |   male | 35.0 |     0 |     0 |  8.0500 |          |       |       |            |      |             |       |       |



#### 2) count categorical values

시리즈의 값이 정수, 문자열, 카테고리 값인 경우에는 `value_counts` 메서드로 각각의 값이 나온 횟수 카운트

```python
np.random.seed(1)
s2 = pd.Series(np.random.randint(6, size=100))
s2.tail()
```

```
95    4
96    5
97    2
98    4
99    3
dtype: int64
```

```python
s2.value_counts()
```

```
1    22
0    18
4    17
5    16
3    14
2    13
dtype: int64
```



**데이터프레임**에는 `value_counts` 메서드가 없으므로 **각 열마다 별도로 적용**해야 한다.

```python
df[0].value_counts()
```

```
3.0    2
4.0    1
0.0    1
Name: 0, dtype: int64
```



#### 3) Sorting

데이터를 정렬하려면 `sort_index` 메서드 `sort_values` 메서드를 사용한다. 

`sort_index` 메서드는 **인덱스 값**을 기준으로, 

`sort_values` 메서드는 **데이터 값**을 기준으로 정렬한다.

앞에서 `s2` 시리즈의 각 데이터 값에 따른 데이터 갯수를 인덱스에 따라 정렬하려면 다음처럼 `sort_index`를 적용한다.

##### (a) s.value_count().sort_index()

```python
s2.value_counts().sort_index()
```

```
0    18
1    22
2    13
3    14
4    17
5    16
dtype: int64
```



##### (b)  s.sort_values()

NaN값이 있는 경우에는 정렬하면 NaN값이 가장 나중으로 간다.

```python
s.sort_values()
```

```
0    0.0
1    1.0
2    2.0
4    4.0
5    5.0
6    6.0
7    7.0
8    8.0
9    9.0
3    NaN
dtype: float64
```



##### (c) s.sort_values(ascending=False)

큰 수에서 작은 수로 반대 방향 정렬하려면 `ascending=False` 인수를 지정한다.

```python
s.sort_values(ascending=False)
```

```
9    9.0
8    8.0
7    7.0
6    6.0
5    5.0
4    4.0
2    2.0
1    1.0
0    0.0
3    NaN
dtype: float64
```



##### (d) df.sort_values(by=1)

데이터프레임에서 `sort_values` 메서드를 사용하려면 `by` 인수로 정렬 기준이 되는 열을 지정해 주어야 한다.

```python
df.sort_values(by=1)
```

|      |    0 |    1 |    2 |    3 |
| ---: | ---: | ---: | ---: | ---: |
|    0 |  0.0 |  0.0 |  3.0 |  2.0 |
|    1 |  3.0 |  0.0 |  2.0 |  1.0 |
|    2 |  3.0 |  2.0 |  4.0 |  NaN |
|    3 |  4.0 |  3.0 |  4.0 |  2.0 |

##### (d-1)

`by` 인수에 리스트 값을 넣으면 이 순서대로 정렬 기준의 우선 순위가 된다. 즉, 리스트의 첫번째 열을 기준으로 정렬한 후 동일한 값이 나오면 그 다음 열로 순서를 따지게 된다.

```python
df.sort_values(by=[1, 2])
```

|      |    0 |    1 |    2 |    3 |
| ---: | ---: | ---: | ---: | ---: |
|    1 |  3.0 |  0.0 |  2.0 |  1.0 |
|    0 |  0.0 |  0.0 |  3.0 |  2.0 |
|    2 |  3.0 |  2.0 |  4.0 |  NaN |
|    3 |  4.0 |  3.0 |  4.0 |  2.0 |





#### 4) Sum : row & column

행과 열의 합계를 구할 때는 `sum(axis)` 메서드를 사용한다. `axis` 인수에는 합계로 인해 없어지는 방향축(0=행, 1=열)을 지정한다.

```python
np.random.seed(1)
df2 = pd.DataFrame(np.random.randint(10, size=(4, 8)))
df2
```

|      |    0 |    1 |    2 |    3 |    4 |    5 |    6 |    7 |
| ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: |
|    0 |    5 |    8 |    9 |    5 |    0 |    0 |    1 |    7 |
|    1 |    6 |    9 |    2 |    4 |    5 |    2 |    4 |    2 |
|    2 |    4 |    7 |    7 |    9 |    1 |    7 |    0 |    6 |
|    3 |    9 |    9 |    7 |    6 |    9 |    1 |    0 |    1 |



##### (a) df.sum(axis=1) 행

행방향 합계를 구할 때는 `sum(axis=1)` 메서드를 사용한다.

```python
df2.sum(axis=1)
```

```
0    35
1    34
2    41
3    42
dtype: int64
```



```python
df2["RowSum"] = df2.sum(axis=1)
df2
```

|      |    0 |    1 |    2 |    3 |    4 |    5 |    6 |    7 | RowSum |
| ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: | -----: |
|    0 |    5 |    8 |    9 |    5 |    0 |    0 |    1 |    7 |     35 |
|    1 |    6 |    9 |    2 |    4 |    5 |    2 |    4 |    2 |     34 |
|    2 |    4 |    7 |    7 |    9 |    1 |    7 |    0 |    6 |     41 |
|    3 |    9 |    9 |    7 |    6 |    9 |    1 |    0 |    1 |     42 |



##### (b) df.sum() 열

열 합계를 구할 때는 `sum(axis=0)` 메서드를 사용하는데 `axis`인수의 디폴트 값이 0이므로 `axis`인수를 생략할 수 있다.

```python
df2.sum()
```

```
0          24
1          33
2          25
3          24
4          15
5          10
6           5
7          16
RowSum    152
dtype: int64
```



```python
df2.loc["ColTotal", :] = df2.sum()
df2
```

|          |    0 |    1 |    2 |    3 |    4 |    5 |    6 |    7 | RowSum |
| -------: | ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: | -----: |
|        0 |  5.0 |  8.0 |  9.0 |  5.0 |  0.0 |  0.0 |  1.0 |  7.0 |   35.0 |
|        1 |  6.0 |  9.0 |  2.0 |  4.0 |  5.0 |  2.0 |  4.0 |  2.0 |   34.0 |
|        2 |  4.0 |  7.0 |  7.0 |  9.0 |  1.0 |  7.0 |  0.0 |  6.0 |   41.0 |
|        3 |  9.0 |  9.0 |  7.0 |  6.0 |  9.0 |  1.0 |  0.0 |  1.0 |   42.0 |
| ColTotal | 24.0 | 33.0 | 25.0 | 24.0 | 15.0 | 10.0 |  5.0 | 16.0 |  152.0 |



##### (c) mean 평균

```python
mean
```

`mean` 메서드는 평균을 구하며 `sum` 메서드와 사용법이 같다.



#### 5) Apply transform (=map)

map과 같은 역할

행이나 열 단위로 더 복잡한 처리를 하고 싶을 때는 `apply` 메서드를 사용한다. 인수로 행 또는 열을 받는 함수를 `apply` 메서드의 인수로 넣으면 각 열(또는 행)을 반복하여 그 함수에 적용시킨다.

```python
df3 = pd.DataFrame({
    'A': [1, 3, 4, 3, 4],
    'B': [2, 3, 1, 2, 3],
    'C': [1, 5, 2, 4, 4]
})
df3
```

|      |    A |    B |    C |
| ---: | ---: | ---: | ---: |
|    0 |    1 |    2 |    1 |
|    1 |    3 |    3 |    5 |
|    2 |    4 |    1 |    2 |
|    3 |    3 |    2 |    4 |
|    4 |    4 |    3 |    4 |



##### (a) apply lambda x (열)

예를 들어 각 열의 최대값과 최소값의 차이를 구하고 싶으면 다음과 같은 람다 함수를 넣는다.

```python
df3.apply(lambda x: x.max() - x.min())  #x는 열
```

```
A    3
B    2
C    4
dtype: int64
```



##### (b) apply axis=1 (행)

만약 행에 대해 적용하고 싶으면 `axis=1` 인수를 쓴다.

```python
df3.apply(lambda x: x.max() - x.min(), axis=1)
```

```
0    1
1    2
2    3
3    2
4    1
dtype: int64
```



##### (c) apply(pd.value_counts)

각 열에 대해 어떤 값이 얼마나 사용되었는지 알고 싶다면 `value_counts` 함수를 넣으면 된다.

```python
df3.apply(pd.value_counts)
```

|      |    A |    B |    C |
| ---: | ---: | ---: | ---: |
|    1 |  1.0 |  1.0 |  1.0 |
|    2 |  NaN |  2.0 |  1.0 |
|    3 |  2.0 |  2.0 |  NaN |
|    4 |  2.0 |  NaN |  2.0 |
|    5 |  NaN |  NaN |  1.0 |



다음과 같이 타이타닉호의 승객 중 나이 20살을 기준으로 성인(adult)과 미성년자(child)를 구별하는 라벨 열을 만들 수 있다.

```python
titanic["adult/child"] = titanic.apply(lambda r: "adult" if r.age >= 20 else "child", axis=1)
titanic.tail()
```

|      | survived | pclass |    sex |  age | sibsp | parch |  fare | embarked |  class |   who | adult_male | deck | embark_town | alive | alone | adult/child |
| ---: | -------: | -----: | -----: | ---: | ----: | ----: | ----: | -------: | -----: | ----: | ---------: | ---: | ----------: | ----: | ----: | ----------: |
|  886 |        0 |      2 |   male | 27.0 |     0 |     0 | 13.00 |        S | Second |   man |       True |  NaN | Southampton |    no |  True |       adult |
|  887 |        1 |      1 | female | 19.0 |     0 |     0 | 30.00 |        S |  First | woman |      False |    B | Southampton |   yes |  True |       child |
|  888 |        0 |      3 | female |  NaN |     1 |     2 | 23.45 |        S |  Third | woman |      False |  NaN | Southampton |    no | False |       child |
|  889 |        1 |      1 |   male | 26.0 |     0 |     0 | 30.00 |        C |  First |   man |       True |    C |   Cherbourg |   yes |  True |       adult |
|  890 |        0 |      3 |   male | 32.0 |     0 |     0 |  7.75 |          |        |       |            |      |             |       |       |             |



#### 6) Fillna Method fillna(0.0)

fill not available

NaN 값은 `fillna` 메서드를 사용하여 원하는 값으로 바꿀 수 있다.

```python
df3.apply(pd.value_counts).fillna(0.0)
```

|      |    A |    B |    C |
| ---: | ---: | ---: | ---: |
|    1 |  1.0 |  1.0 |  1.0 |
|    2 |  0.0 |  2.0 |  1.0 |
|    3 |  2.0 |  2.0 |  0.0 |
|    4 |  2.0 |  0.0 |  2.0 |
|    5 |  0.0 |  0.0 |  1.0 |



#### 7) Astype Method astype(int)

`astype` 메서드로 전체 데이터의 자료형을 바꾸는 것도 가능하다. 정수, 소수 등으로..

```python
df3.apply(pd.value_counts).fillna(0).astype(int)
```

|      |    A |    B |    C |
| ---: | ---: | ---: | ---: |
|    1 |    1 |    1 |    1 |
|    2 |    0 |    2 |    1 |
|    3 |    2 |    2 |    0 |
|    4 |    2 |    0 |    2 |
|    5 |    0 |    0 |    1 |



#### 8) Convert integer to categorical

실수 값을 크기 기준으로 하여 카테고리 값으로 변환하고 싶을 때는 다음과 같은 명령을 사용한다.

- `cut`: 실수 값의 경계선을 지정하는 경우
- `qcut`: 갯수가 똑같은 구간으로 나누는 경우

예를 들어 다음과 같은 나이 데이터가 있다고 하자.

```python
ages = [0, 2, 10, 21, 23, 37, 31, 61, 20, 41, 32, 101]
```



`cut` 명령을 사용하면 실수값을 다음처럼 카테고리 값으로 바꿀 수 있다. **`bins` 인수는 카테고리를 나누는 기준값**이 된다. 영역을 넘는 값은 NaN으로 처리된다.

```python
bins = [1, 20, 30, 50, 70, 100]
labels = ["미성년자", "청년", "중년", "장년", "노년"]
cats = pd.cut(ages, bins, labels=labels)
cats
```



```python
[NaN, 미성년자, 미성년자, 청년, 청년, ..., 장년, 미성년자, 중년, 중년, NaN]
Length: 12
Categories (5, object): [미성년자 < 청년 < 중년 < 장년 < 노년]
```



`cut` 명령이 반환하는 값은 `Categorical` 클래스 객체이다. 이 객체는 `categories` 속성으로 라벨 문자열을, `codes` 속성으로 정수로 인코딩한 카테고리 값을 가진다.

```python
type(cats)
```

```python
pandas.core.arrays.categorical.Categorical
```

```python
cats.categories
```



```python
Index(['미성년자', '청년', '중년', '장년', '노년'], dtype='object')
```

```python
cats.codes
```

```python
array([-1,  0,  0,  1,  1,  2,  2,  3,  0,  2,  2, -1], dtype=int8)
```



```python
df4 = pd.DataFrame(ages, columns=["ages"])
df4["age_cat"] = pd.cut(df4.ages, bins, labels=labels)
df4
```

|      | ages |  age_cat |
| ---: | ---: | -------: |
|    0 |    0 |      NaN |
|    1 |    2 | 미성년자 |
|    2 |   10 | 미성년자 |
|    3 |   21 |     청년 |
|    4 |   23 |     청년 |
|    5 |   37 |     중년 |
|    6 |   31 |     중년 |
|    7 |   61 |     장년 |
|    8 |   20 | 미성년자 |
|    9 |   41 |     중년 |
|   10 |   32 |     중년 |
|   11 |  101 |      NaN |



따라서 위 데이터프레임의 age_cat 열값은 문자열이 아니다. 이를 문자열로 만들려면 `astype` 메서드를 사용해야 한다.

```python
df4.age_cat.astype(str) + df4.ages.astype(str)
```

```python
0       nan0
1      미성년자2
2     미성년자10
3       청년21
4       청년23
5       중년37
6       중년31
7       장년61
8     미성년자20
9       중년41
10      중년32
11    nan101
dtype: object
```



`qcut` 명령은 구간 경계선을 지정하지 않고 데이터 갯수가 같도록 지정한 수의 구간으로 나눈다. 예를 들어 다음 코드는 1000개의 데이터를 4개의 구간으로 나누는데 각 구간은 250개씩의 데이터를 가진다.

```python
data = np.random.randn(1000)
cats = pd.qcut(data, 4, labels=["Q1", "Q2", "Q3", "Q4"])
cats
```

```python
[Q2, Q1, Q2, Q3, Q1, ..., Q1, Q1, Q4, Q4, Q2]
Length: 1000
Categories (4, object): [Q1 < Q2 < Q3 < Q4]
```



```python
pd.value_counts(cats)
```

```python
Q4    250
Q3    250
Q2    250
Q1    250
dtype: int64
```



## 5. DataFrame: Index manipulation

#### 1) Set & delete index

데이터프레임에 인덱스로 들어가 있어야 할 데이터가 일반 데이터 열에 들어가 있거나 반대로 일반 데이터 열이어야 할 것이 인덱스로 되어 있을 수 있다. 이 때는 set_index 명령이나 reset_index 명령으로 인덱스와 일반 데이터 열을 교환할 수 있다.

```python
np.random.seed(0)
df1 = pd.DataFrame(np.vstack([list('ABCDE'),
                              np.round(np.random.rand(3, 5), 2)]).T,
                   columns=["C1", "C2", "C3", "C4"])
df1
```

|      |   C1 |   C2 |   C3 |   C4 |
| ---: | ---: | ---: | ---: | ---: |
|    0 |    A | 0.55 | 0.65 | 0.79 |
|    1 |    B | 0.72 | 0.44 | 0.53 |
|    2 |    C |  0.6 | 0.89 | 0.57 |
|    3 |    D | 0.54 | 0.96 | 0.93 |
|    4 |    E | 0.42 | 0.38 | 0.07 |



##### (a) set_index 

: 기존의 행 인덱스를 제거하고 데이터 열 중 하나를 인덱스로 설정

```python
set_index
```

`set_index` 메서드로 특정한 열을 인덱스로 설정할 수 있다. 이 때 기존의 인덱스는 없어진다.

```python
df2 = df1.set_index("C1")
df2
```

|      |   C2 |   C3 |   C4 |
| ---: | ---: | ---: | ---: |
|   C1 |      |      |      |
|    A | 0.55 | 0.65 | 0.79 |
|    B | 0.72 | 0.44 | 0.53 |
|    C |  0.6 | 0.89 | 0.57 |
|    D | 0.54 | 0.96 | 0.93 |
|    E | 0.42 | 0.38 | 0.07 |

마찬가지로 C2열을 인덱스로 지정하면 기존의 인덱스는 사라진다.

```python
df2.set_index("C2")
```

|      |   C3 |   C4 |
| ---: | ---: | ---: |
|   C2 |      |      |
| 0.55 | 0.65 | 0.79 |
| 0.72 | 0.44 | 0.53 |
|  0.6 | 0.89 | 0.57 |
| 0.54 | 0.96 | 0.93 |
| 0.42 | 0.38 | 0.07 |



#### (b) reset_index 

: 기존의 행 인덱스를 제거하고 인덱스를 데이터 열로 추가

```python
reset_index
```



반대로 `reset_index` 메서드를 쓰면 인덱스를 보통의 자료열로 바꿀 수도 있다. 이 때 인덱스 열은 자료열의 가장 선두로 삽입된다. 데이터프레임의 인덱스는 정수로 된 디폴트 인덱스로 바뀐다.

```python
df2.reset_index()
```

|      |   C1 |   C2 |   C3 |   C4 |
| ---: | ---: | ---: | ---: | ---: |
|    0 |    A | 0.55 | 0.65 | 0.79 |
|    1 |    B | 0.72 | 0.44 | 0.53 |
|    2 |    C |  0.6 | 0.89 | 0.57 |
|    3 |    D | 0.54 | 0.96 | 0.93 |
|    4 |    E | 0.42 | 0.38 | 0.07 |



`reset_index` 메서드를 호출할 때 인수 `drop=True` 로 설정하면 인덱스 열을 보통의 자료열로 올리는 것이 아니라 그냥 버리게 된다.

```python
df2.reset_index(drop=True)
```

|      |   C2 |   C3 |   C4 |
| ---: | ---: | ---: | ---: |
|    0 | 0.55 | 0.65 | 0.79 |
|    1 | 0.72 | 0.44 | 0.53 |
|    2 |  0.6 | 0.89 | 0.57 |
|    3 | 0.54 | 0.96 | 0.93 |
|    4 | 0.42 | 0.38 | 0.07 |



#### 2) Multi-index

행이나 열에 여러 계층을 가지는 인덱스 즉, 다중 인덱스(multi-index)를 설정할 수도 있다. 데이터프레임을 생성할 때 `columns` 인수에 다음 예제처럼 리스트의 리스트(행렬) 형태로 인덱스를 넣으면 다중 열 인덱스를 가지게 된다.

```python
np.random.seed(0)
df3 = pd.DataFrame(np.round(np.random.randn(5, 4), 2),
                   columns=[["A", "A", "B", "B"],
                            ["C1", "C2", "C1", "C2"]])
df3
```

|      |     A |     B |      |       |
| ---: | ----: | ----: | ---: | ----: |
|      |    C1 |    C2 |   C1 |    C2 |
|    0 |  1.76 |  0.40 | 0.98 |  2.24 |
|    1 |  1.87 | -0.98 | 0.95 | -0.15 |
|    2 | -0.10 |  0.41 | 0.14 |  1.45 |
|    3 |  0.76 |  0.12 | 0.44 |  0.33 |
|    4 |  1.49 | -0.21 | 0.31 | -0.85 |



##### (a) columns.names 다중 열 인덱스

```
columns.names
```

다중 인덱스는 이름을 지정하면 더 편리하게 사용할 수 있다. 열 인덱스들의 이름 지정은 `columns` 객체의 `names` 속성에 리스트를 넣어서 지정한다.

```python
df3.columns.names = ["Cidx1", "Cidx2"]
df3
```

| Cidx1 |     A |     B |      |       |
| ----: | ----: | ----: | ---: | ----: |
| Cidx2 |    C1 |    C2 |   C1 |    C2 |
|     0 |  1.76 |  0.40 | 0.98 |  2.24 |
|     1 |  1.87 | -0.98 | 0.95 | -0.15 |
|     2 | -0.10 |  0.41 | 0.14 |  1.45 |
|     3 |  0.76 |  0.12 | 0.44 |  0.33 |
|     4 |  1.49 | -0.21 | 0.31 | -0.85 |



##### (b) index.names 다중 행 인덱스

```python
index.names
```

마찬가지로 데이터프레임을 생성할 때 `index` 인수에 리스트의 리스트(행렬) 형태로 인덱스를 넣으면 다중 (행) 인덱스를 가진다. 행 인덱스들의 이름 지정은 `index` 객체의 `names` 속성에 리스트를 넣어서 지정한다.

```python
np.random.seed(0)
df4 = pd.DataFrame(np.round(np.random.randn(6, 4), 2),
                   columns=[["A", "A", "B", "B"],
                            ["C", "D", "C", "D"]],
                   index=[["M", "M", "M", "F", "F", "F"],
                          ["id_" + str(i + 1) for i in range(3)] * 2])
df4.columns.names = ["Cidx1", "Cidx2"]
df4.index.names = ["Ridx1", "Ridx2"]
df4
```

|       | Cidx1 |     A |    B |       |      |
| ----: | ----: | ----: | ---: | ----: | ---: |
|       | Cidx2 |     C |    D |     C |    D |
| Ridx1 | Ridx2 |       |      |       |      |
|     M |  id_1 |  1.76 | 0.40 |  0.98 | 2.24 |
|  id_2 |  1.87 | -0.98 | 0.95 | -0.15 |      |
|  id_3 | -0.10 |  0.41 | 0.14 |  1.45 |      |
|     F |  id_1 |  0.76 | 0.12 |  0.44 | 0.33 |
|  id_2 |  1.49 | -0.21 | 0.31 | -0.85 |      |
|  id_3 | -2.55 |  0.65 | 0.86 | -0.74 |      |



#### 3) Convert row to column

`stack` 메서드나 `unstack` 메서드를 쓰면 열 인덱스를 행 인덱스로 바꾸거나 반대로 행 인덱스를 열 인덱스로 바꿀 수 있다. 인덱스를 지정할 때는 문자열 이름과 순서를 표시하는 숫자 인덱스를 모두 사용할 수 있다.

- `stack`
- 열 인덱스 -> 행 인덱스로 변환
- `unstack`
- 행 인덱스 -> 열 인덱스로 변환



##### (a) df.stack(열인덱스)

`stack` 열 인덱스 -> 행 인덱스로 변환. 열 인덱스가 반시계 방향으로 90도 회전한 것과 비슷한 모양이 된다.

##### (b) df.unstack(행익덱스)

 `unstack` 행 인덱스 -> 열 인덱스로 변환. 행 인덱스가 시계 방향으로 90도 회전한 것과 비슷하다. 

```python
df4.stack("Cidx1")
```

|       |       | Cidx2 |     C |    D |
| ----: | ----: | ----: | ----: | ---: |
| Ridx1 | Ridx2 | Cidx1 |       |      |
|     M |  id_1 |     A |  1.76 | 0.40 |
|     B |  0.98 |  2.24 |       |      |
|  id_2 |     A |  1.87 | -0.98 |      |
|     B |  0.95 | -0.15 |       |      |
|  id_3 |     A | -0.10 |  0.41 |      |
|     B |  0.14 |  1.45 |       |      |
|     F |  id_1 |     A |  0.76 | 0.12 |
|     B |  0.44 |  0.33 |       |      |
|  id_2 |     A |  1.49 | -0.21 |      |
|     B |  0.31 | -0.85 |       |      |
|  id_3 |     A | -2.55 |  0.65 |      |
|     B |  0.86 | -0.74 |       |      |

```python
df4.stack(1)
```

|       |       | Cidx1 |    A |    B |
| ----: | ----: | ----: | ---: | ---: |
| Ridx1 | Ridx2 | Cidx2 |      |      |
|     M |  id_1 |     C | 1.76 | 0.98 |
|     D |  0.40 |  2.24 |      |      |
|  id_2 |     C |  1.87 | 0.95 |      |
|     D | -0.98 | -0.15 |      |      |
|  id_3 |     C | -0.10 | 0.14 |      |
|     D |  0.41 |  1.45 |      |      |
|     F |  id_1 |     C | 0.76 | 0.44 |
|     D |  0.12 |  0.33 |      |      |
|  id_2 |     C |  1.49 | 0.31 |      |
|     D | -0.21 | -0.85 |      |      |
|  id_3 |     C | -2.55 | 0.86 |      |
|     D |  0.65 | -0.74 |      |      |

```python
df4.unstack("Ridx2")
```

| Cidx1 |    A |    B |       |      |       |      |      |      |      |      |       |       |
| ----: | ---: | ---: | ----: | ---: | ----: | ---: | ---: | ---: | ---: | ---: | ----: | ----: |
| Cidx2 |    C |    D |     C |    D |       |      |      |      |      |      |       |       |
| Ridx2 | id_1 | id_2 |  id_3 | id_1 |  id_2 | id_3 | id_1 | id_2 | id_3 | id_1 |  id_2 |  id_3 |
| Ridx1 |      |      |       |      |       |      |      |      |      |      |       |       |
|     F | 0.76 | 1.49 | -2.55 | 0.12 | -0.21 | 0.65 | 0.44 | 0.31 | 0.86 | 0.33 | -0.85 | -0.74 |
|     M | 1.76 | 1.87 | -0.10 | 0.40 | -0.98 | 0.41 | 0.98 | 0.95 | 0.14 | 2.24 | -0.15 |  1.45 |

```python
df4.unstack(0)
```

| Cidx1 |     A |     B |       |       |      |      |       |       |
| ----: | ----: | ----: | ----: | ----: | ---: | ---: | ----: | ----: |
| Cidx2 |     C |     D |     C |     D |      |      |       |       |
| Ridx1 |     F |     M |     F |     M |    F |    M |     F |     M |
| Ridx2 |       |       |       |       |      |      |       |       |
|  id_1 |  0.76 |  1.76 |  0.12 |  0.40 | 0.44 | 0.98 |  0.33 |  2.24 |
|  id_2 |  1.49 |  1.87 | -0.21 | -0.98 | 0.31 | 0.95 | -0.85 | -0.15 |
|  id_3 | -2.55 | -0.10 |  0.65 |  0.41 | 0.86 | 0.14 | -0.74 |  1.45 |



#### 4) Indexing - multi-index

데이터프레임이 다중 인덱스를 가지는 경우에는 인덱스 값이 하나의 라벨이나 숫자가 아니라 **`()`로 둘러싸인 튜플**이 되어야 한다. 예를 들어 앞에서 만든 `df3` 데이터프레임의 경우 다음과 같이 인덱싱할 수 있다.



##### (a) 다중인덱스 - 인덱스 값 튜플

```python
df3
```

| Cidx1 |     A |     B |      |       |
| ----: | ----: | ----: | ---: | ----: |
| Cidx2 |    C1 |    C2 |   C1 |    C2 |
|     0 |  1.76 |  0.40 | 0.98 |  2.24 |
|     1 |  1.87 | -0.98 | 0.95 | -0.15 |
|     2 | -0.10 |  0.41 | 0.14 |  1.45 |
|     3 |  0.76 |  0.12 | 0.44 |  0.33 |
|     4 |  1.49 | -0.21 | 0.31 | -0.85 |

```python
df3[("B", "C1")]
```

```
0    0.98
1    0.95
2    0.14
3    0.44
4    0.31
Name: (B, C1), dtype: float64
```



##### (b) loc - 튜플

`loc` 인덱스를 사용하는 경우에도 마찬가지로 튜플을 써야 한다.

```python
df3.loc[0, ("B", "C1")]
```

```
0.98
```

```python
df3.loc[0, ("B", "C1")] = 100
df3
```

| Cidx1 |     A |     B |        |       |
| ----: | ----: | ----: | -----: | ----: |
| Cidx2 |    C1 |    C2 |     C1 |    C2 |
|     0 |  1.76 |  0.40 | 100.00 |  2.24 |
|     1 |  1.87 | -0.98 |   0.95 | -0.15 |
|     2 | -0.10 |  0.41 |   0.14 |  1.45 |
|     3 |  0.76 |  0.12 |   0.44 |  0.33 |
|     4 |  1.49 | -0.21 |   0.31 | -0.85 |



##### (c) iloc - 인덱스 번호

단, `iloc` 인덱서를 사용하는 경우에는 튜플 형태의 다중인덱스를 사용할 수 없다.

```python
df3.iloc[0, 2]
```

```
100.0
```



##### (d) 하나의 값 - 상위값

만약 하나의 레벨 값만 넣으면 다중 인덱스 중에서 가장 상위의 값을 지정한 것으로 본다.

```python
df3['A']
```

| Cidx2 |    C1 |    C2 |
| ----: | ----: | ----: |
|     0 |  1.76 |  0.40 |
|     1 |  1.87 | -0.98 |
|     2 | -0.10 |  0.41 |
|     3 |  0.76 |  0.12 |
|     4 |  1.49 | -0.21 |



##### (e-1) 데이터프레임 - df.loc[(행:행),(열:열)]

`df4` 데이터프레임은 다음과 같이 인덱싱할 수 있다.

```python
df4
```

|       | Cidx1 |     A |    B |       |      |
| ----: | ----: | ----: | ---: | ----: | ---: |
|       | Cidx2 |     C |    D |     C |    D |
| Ridx1 | Ridx2 |       |      |       |      |
|     M |  id_1 |  1.76 | 0.40 |  0.98 | 2.24 |
|  id_2 |  1.87 | -0.98 | 0.95 | -0.15 |      |
|  id_3 | -0.10 |  0.41 | 0.14 |  1.45 |      |
|     F |  id_1 |  0.76 | 0.12 |  0.44 | 0.33 |
|  id_2 |  1.49 | -0.21 | 0.31 | -0.85 |      |
|  id_3 | -2.55 |  0.65 | 0.86 | -0.74 |      |

```python
df4.loc[("M", "id_1"), ("A", "C")]
```

```python
1.76
```



```python
df4.loc[:, ("A", "C")]
```

```python
Ridx1  Ridx2
M      id_1     1.76
       id_2     1.87
       id_3    -0.10
F      id_1     0.76
       id_2     1.49
       id_3    -2.55
Name: (A, C), dtype: float64
```



```python
df4.loc[("M", "id_1"), :]
```

```python
Cidx1  Cidx2
A      C        1.76
       D        0.40
B      C        0.98
       D        2.24
Name: (M, id_1), dtype: float64
```



##### (e-2) 데이터프레임 - df.loc[(추가행인덱스),(추가열)] = df(추가값)

```python
df4.loc[("All", "All"), :] = df4.sum()
df4
```

|       | Cidx1 |     A |    B |       |      |
| ----: | ----: | ----: | ---: | ----: | ---: |
|       | Cidx2 |     C |    D |     C |    D |
| Ridx1 | Ridx2 |       |      |       |      |
|     M |  id_1 |  1.76 | 0.40 |  0.98 | 2.24 |
|  id_2 |  1.87 | -0.98 | 0.95 | -0.15 |      |
|  id_3 | -0.10 |  0.41 | 0.14 |  1.45 |      |
|     F |  id_1 |  0.76 | 0.12 |  0.44 | 0.33 |
|  id_2 |  1.49 | -0.21 | 0.31 | -0.85 |      |
|  id_3 | -2.55 |  0.65 | 0.86 | -0.74 |      |
|   All |   All |  3.23 | 0.39 |  3.68 | 2.28 |



##### (e-3) 테이터프레임 df.loc[상위 행인덱스]

`loc`를 사용하는 경우에도 튜플이 아닌 하나의 값만 쓰면 가장 상위의 인덱스를 지정한 것과 같다.

```python
df4.loc["M"]
```

| Cidx1 |     A |     B |      |       |
| ----: | ----: | ----: | ---: | ----: |
| Cidx2 |     C |     D |    C |     D |
| Ridx2 |       |       |      |       |
|  id_1 |  1.76 |  0.40 | 0.98 |  2.24 |
|  id_2 |  1.87 | -0.98 | 0.95 | -0.15 |
|  id_3 | -0.10 |  0.41 | 0.14 |  1.45 |



##### (f) slice(None) : 특정레벨 모든 인덱스 df.loc[( 행인덱스,  slice(None)) :]

```python
slice(None)
```

특정 레벨의 모든 인덱스 값을 인덱싱할 때는 슬라이스를 사용한다. 다만 다중 인덱스의 튜플 내에서는 `:` 슬라이스 기호를 사용할 수 없고 대신 `slice(None)` 값을 사용해야 한다.

```python
df4.loc[("M", slice(None)), :]
```

|       | Cidx1 |     A |    B |       |      |
| ----: | ----: | ----: | ---: | ----: | ---: |
|       | Cidx2 |     C |    D |     C |    D |
| Ridx1 | Ridx2 |       |      |       |      |
|     M |  id_1 |  1.76 | 0.40 |  0.98 | 2.24 |
|  id_2 |  1.87 | -0.98 | 0.95 | -0.15 |      |
|  id_3 | -0.10 |  0.41 | 0.14 |  1.45 |      |

```python
df4.loc[(slice(None), "id_1"), :]
```

|       | Cidx1 |    A |    B |      |      |
| ----: | ----: | ---: | ---: | ---: | ---: |
|       | Cidx2 |    C |    D |    C |    D |
| Ridx1 | Ridx2 |      |      |      |      |
|     M |  id_1 | 1.76 | 0.40 | 0.98 | 2.24 |
|     F |  id_1 | 0.76 | 0.12 | 0.44 | 0.33 |



#### 5) Change order - multi index

##### (a) swaplevel(i, j, axis)

다중 인덱스의 인덱스 순서를 바꾸고 싶으면 `swaplevel` 명령을 사용한다.``

`i`와 `j`는 교환하고자 하는 인덱스 라벨(혹은 인덱스 번호)이고 `axis`는 0일 때 행 인덱스, 1일 때 열 인덱스를 뜻한다. 디폴트는 행 인덱스이다.

```python
df5 = df4.swaplevel("Ridx1", "Ridx2")
df5
```

|       | Cidx1 |     A |     B |      |       |
| ----: | ----: | ----: | ----: | ---: | ----: |
|       | Cidx2 |     C |     D |    C |     D |
| Ridx2 | Ridx1 |       |       |      |       |
|  id_1 |     M |  1.76 |  0.40 | 0.98 |  2.24 |
|  id_2 |     M |  1.87 | -0.98 | 0.95 | -0.15 |
|  id_3 |     M | -0.10 |  0.41 | 0.14 |  1.45 |
|  id_1 |     F |  0.76 |  0.12 | 0.44 |  0.33 |
|  id_2 |     F |  1.49 | -0.21 | 0.31 | -0.85 |
|  id_3 |     F | -2.55 |  0.65 | 0.86 | -0.74 |
|   All |   All |  3.23 |  0.39 | 3.68 |  2.28 |

```python
df6 = df4.swaplevel("Cidx1", "Cidx2", 1)
df6
```

|       | Cidx2 |     C |    D |     C |    D |
| ----: | ----: | ----: | ---: | ----: | ---: |
|       | Cidx1 |     A |    A |     B |    B |
| Ridx1 | Ridx2 |       |      |       |      |
|     M |  id_1 |  1.76 | 0.40 |  0.98 | 2.24 |
|  id_2 |  1.87 | -0.98 | 0.95 | -0.15 |      |
|  id_3 | -0.10 |  0.41 | 0.14 |  1.45 |      |
|     F |  id_1 |  0.76 | 0.12 |  0.44 | 0.33 |
|  id_2 |  1.49 | -0.21 | 0.31 | -0.85 |      |
|  id_3 | -2.55 |  0.65 | 0.86 | -0.74 |      |
|   All |   All |  3.23 | 0.39 |  3.68 | 2.28 |



#### 6) Sorting - multi-index

##### (a) df5.sort_index(level=0)

다중 인덱스가 있는 데이터프레임을 `sort_index`로 정렬할 때는 `level` 인수를 사용하여 어떤 인덱스를 기준으로 정렬하는지 알려주어야 한다.

```python
df5.sort_index(level=0)
```

|       | Cidx1 |     A |     B |       |       |
| ----: | ----: | ----: | ----: | ----: | ----: |
|       | Cidx2 |     C |     D |     C |     D |
| Ridx2 | Ridx1 |       |       |       |       |
|   All |   All |  3.23 |  0.39 |  3.68 |  2.28 |
|  id_1 |     F |  0.76 |  0.12 |  0.44 |  0.33 |
|     M |  1.76 |  0.40 |  0.98 |  2.24 |       |
|  id_2 |     F |  1.49 | -0.21 |  0.31 | -0.85 |
|     M |  1.87 | -0.98 |  0.95 | -0.15 |       |
|  id_3 |     F | -2.55 |  0.65 |  0.86 | -0.74 |
|     M | -0.10 |  0.41 |  0.14 |  1.45 |       |

```python
df6.sort_index(axis=1, level=0)
```

|       | Cidx2 |    C |     D |       |      |
| ----: | ----: | ---: | ----: | ----: | ---: |
|       | Cidx1 |    A |     B |     A |    B |
| Ridx1 | Ridx2 |      |       |       |      |
|     M |  id_1 | 1.76 |  0.98 |  0.40 | 2.24 |
|  id_2 |  1.87 | 0.95 | -0.98 | -0.15 |      |
|  id_3 | -0.10 | 0.14 |  0.41 |  1.45 |      |
|     F |  id_1 | 0.76 |  0.44 |  0.12 | 0.33 |
|  id_2 |  1.49 | 0.31 | -0.21 | -0.85 |      |
|  id_3 | -2.55 | 0.86 |  0.65 | -0.74 |      |
|   All |   All | 3.23 |  3.68 |  0.39 | 2.28 |